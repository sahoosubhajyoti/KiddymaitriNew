<!DOCTYPE html>
<html>
<head>
    <title>Neon Math Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;700&family=Noto+Sans+Oriya:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Orbitron', 'Noto Sans Devanagari', 'Noto Sans Oriya', sans-serif; 
            touch-action: none; 
        }
        canvas { 
            display: block; 
            margin: 0 auto; 
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
        }
        #restartBtn {
            display: none; 
            position: absolute; 
            top: 60%; left: 50%; 
            transform: translate(-50%, -50%); 
            padding: 15px 40px; 
            font-size: 24px; 
            font-family: 'Orbitron', sans-serif;
            background: rgba(0, 0, 0, 0.9); 
            border: 2px solid #00f3ff; 
            border-radius: 15px; 
            color: #00f3ff; 
            cursor: pointer; 
            text-transform: uppercase;
            box-shadow: 0 0 30px #00f3ff;
            z-index: 100;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<button id="restartBtn" onclick="location.reload()">System Failure<br><span style="font-size:16px">Tap to Reboot</span></button>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const restartBtn = document.getElementById("restartBtn");

    canvas.width = window.innerWidth > 500 ? 400 : window.innerWidth; 
    canvas.height = window.innerHeight;

    // --- üåê LOCALIZATION ---
    const dictionary = {
        en: { score: "SCORE", lives: "LIVES", even: "EVEN", odd: "ODD", title: "NEON MATH", howTo: "HOW TO PLAY:", rule1: "Tap EVEN for: 0, 2, 4...", rule2: "Tap ODD for: 1, 3, 5...", start: "TAP TO START", gameOver: "System Failure", reboot: "Tap to Reboot", font: "'Orbitron'" },
        hin: { score: "‡§∏‡•ç‡§ï‡•ã‡§∞", lives: "‡§ú‡•Ä‡§µ‡§®", even: "‡§∏‡§Æ", odd: "‡§µ‡§ø‡§∑‡§Æ", title: "‡§®‡§ø‡§Ø‡•ã‡§® ‡§ó‡§£‡§ø‡§§", howTo: "‡§ï‡•à‡§∏‡•á ‡§ñ‡•á‡§≤‡•á‡§Ç:", rule1: "‡§∏‡§Æ ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç: 0, 2, 4...", rule2: "‡§µ‡§ø‡§∑‡§Æ ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç: 1, 3, 5...", start: "‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ü‡•à‡§™ ‡§ï‡§∞‡•á‡§Ç", gameOver: "‡§ñ‡•á‡§≤ ‡§ñ‡§§‡•ç‡§Æ", reboot: "‡§™‡•Å‡§®‡§É ‡§Ü‡§∞‡§Ç‡§≠ ‡§ï‡§∞‡•á‡§Ç", font: "'Noto Sans Devanagari'" },
        odi: { score: "‡¨∏‡≠ç‡¨ï‡≠ã‡¨∞", lives: "‡¨ú‡≠Ä‡¨¨‡¨®", even: "‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ", odd: "‡¨Ö‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ", title: "‡¨®‡¨ø‡¨ì‡¨®‡≠ç ‡¨ó‡¨£‡¨ø‡¨§", howTo: "‡¨ï‡¨ø‡¨™‡¨∞‡¨ø ‡¨ñ‡≠á‡¨≥‡¨ø‡¨¨‡≠á:", rule1: "‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ ‡¨∏‡¨Ç‡¨ñ‡≠ç‡≠ü‡¨æ ‡¨¨‡¨æ‡¨õ‡¨®‡≠ç‡¨§‡≠Å: 0, 2, 4...", rule2: "‡¨Ö‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ ‡¨∏‡¨Ç‡¨ñ‡≠ç‡≠ü‡¨æ ‡¨¨‡¨æ‡¨õ‡¨®‡≠ç‡¨§‡≠Å: 1, 3, 5...", start: "‡¨Ü‡¨∞‡¨Æ‡≠ç‡¨≠ ‡¨ï‡¨∞‡¨ø‡¨¨‡¨æ‡¨ï‡≠Å ‡¨ü‡≠ç‡≠ü‡¨æ‡¨™‡≠ç ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å", gameOver: "‡¨ñ‡≠á‡¨≥ ‡¨∂‡≠á‡¨∑", reboot: "‡¨™‡≠Å‡¨®‡¨É ‡¨Ü‡¨∞‡¨Æ‡≠ç‡¨≠ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å", font: "'Noto Sans Oriya'" }
    };

    const urlParams = new URLSearchParams(window.location.search);
    const langCode = urlParams.get('lang') || 'en';
    const t = dictionary[langCode] || dictionary['en'];

    restartBtn.innerHTML = `${t.gameOver}<br><span style="font-size:16px">${t.reboot}</span>`;
    restartBtn.style.fontFamily = t.font;

    // --- üìä DETAILED ANALYTICS ---
    let sessionData = {
        startTime: null,
        endTime: null,
        duration: 0,
        totalCorrect: 0,
        totalWrong: 0,
        totalMissed: 0,
        ballHistory: [] // Will store detailed object for each ball
    };

    // --- GAME STATE ---
    let stars = [], explosions = [], popups = [], trail = [];         
    let gameState = "INSTRUCTIONS"; 
    let score = 0;
    let lives = 3; 
    let gameSpeed = 4;
    let gridOffset = 0;     

    // Initial Ball Setup
    let ball = { 
        x: canvas.width / 2, 
        y: -100, 
        radius: 25, 
        number: generateNumber(), 
        state: "FALLING", 
        targetBasket: null,
        spawnTime: null // Will be set when game starts
    };

    const btnHeight = 60; 
    const btnRadius = 20; 
    const btnY = canvas.height - btnHeight - 30; 

    let baskets = [
        { label: t.even, x: 20, y: btnY, width: (canvas.width/2)-25, height: btnHeight, color: "#00f3ff", active: false, type: "EVEN" },
        { label: t.odd, x: (canvas.width/2)+5, y: btnY, width: (canvas.width/2)-25, height: btnHeight, color: "#ff0099", active: false, type: "ODD" }
    ];

    for(let i=0; i<80; i++) {
        stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2, speed: Math.random() * 0.5 + 0.1, alpha: Math.random() });
    }

    // --- INPUT ---
    canvas.addEventListener('pointerdown', (e) => {
        if (gameState === "INSTRUCTIONS") {
            gameState = "PLAYING";
            sessionData.startTime = Date.now();
            ball.spawnTime = Date.now(); // Mark the first ball's start time
            return;
        }

        if (gameState === "GAMEOVER" || ball.state === "SUCKED") return;

        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        baskets.forEach(basket => {
            if (clickX > basket.x && clickX < basket.x + basket.width &&
                clickY > basket.y && clickY < basket.y + basket.height) {
                
                basket.active = true;
                setTimeout(() => basket.active = false, 150);
                startSuck(basket);
            }
        });
    });

    // --- LOGIC ---
    function generateNumber() { return Math.floor(Math.random() * 100); }
    function startSuck(basket) { ball.state = "SUCKED"; ball.targetBasket = basket; }

    function createExplosion(x, y, color) {
        for(let i=0; i<20; i++) {
            explosions.push({ x: x, y: y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, life: 1.0, color: color });
        }
    }

    function update() {
        stars.forEach(p => { p.y += p.speed; if (p.y > canvas.height) p.y = 0; });
        gridOffset = (gridOffset + 1) % 40;

        if (gameState !== "PLAYING") return;

        if (ball.state === "FALLING") {
            ball.y += gameSpeed;
            if (score > 0) { trail.push({x: ball.x, y: ball.y, size: ball.radius}); if (trail.length > 10) trail.shift(); }
            
            // MISSED BALL LOGIC
            if (ball.y > canvas.height + 50) {
                recordBallEvent("MISSED", null); // Log Miss
                sessionData.totalMissed++;
                loseLife();
                resetBall();
            }

        } else if (ball.state === "SUCKED") {
            let targetX = ball.targetBasket.x + ball.targetBasket.width / 2;
            let targetY = ball.targetBasket.y + ball.targetBasket.height / 2;
            ball.x += (targetX - ball.x) * 0.25; ball.y += (targetY - ball.y) * 0.25; ball.radius *= 0.85;

            if (ball.radius < 2) {
                validateCatch(ball.targetBasket);
                resetBall();
            }
        }

        for (let i = explosions.length - 1; i >= 0; i--) { explosions[i].x += explosions[i].vx; explosions[i].y += explosions[i].vy; explosions[i].life -= 0.05; if (explosions[i].life <= 0) explosions.splice(i, 1); }
        for (let i = popups.length - 1; i >= 0; i--) { popups[i].y -= 2; popups[i].life -= 1; if (popups[i].life <= 0) popups.splice(i, 1); }
    }

    // üìù DATA RECORDER FUNCTION
    function recordBallEvent(result, basketChosen) {
        const endTime = Date.now();
        // If spawnTime is somehow null (glitch protection), assume 0 duration
        const startTime = ball.spawnTime || endTime; 

        const ballRecord = {
            number: ball.number,
            spawnTime: new Date(startTime).toISOString(),
            endTime: new Date(endTime).toISOString(),
            reactionTimeMs: endTime - startTime, // How long ball was alive
            result: result, // "CORRECT", "WRONG", "MISSED"
            basketChosen: basketChosen // "EVEN", "ODD", or null
        };

        sessionData.ballHistory.push(ballRecord);
    }

    function validateCatch(basket) {
        let isNumberEven = ball.number % 2 === 0;
        let isBasketEven = basket.type === "EVEN"; 

        if ((isBasketEven && isNumberEven) || (!isBasketEven && !isNumberEven)) {
            // CORRECT
            recordBallEvent("CORRECT", basket.type);
            sessionData.totalCorrect++;
            score += 10;
            gameSpeed += 0.2;
            createExplosion(basket.x + basket.width/2, basket.y, "#00ff00");
            spawnPopup("+10", basket.x + basket.width/2, basket.y - 50, "#00ff00");
        } else {
            // WRONG
            recordBallEvent("WRONG", basket.type);
            sessionData.totalWrong++;
            createExplosion(basket.x + basket.width/2, basket.y, "red");
            spawnPopup("ERROR", basket.x + basket.width/2, basket.y - 50, "red");
            loseLife();
            shakeScreen();
        }
    }

    function loseLife() {
        lives--;
        if (lives <= 0) endGame();
        if (navigator.vibrate) navigator.vibrate(300);
    }

    function resetBall() {
        ball.state = "FALLING"; 
        ball.y = -60; 
        ball.x = Math.random() * (canvas.width - 60) + 30; 
        ball.radius = 25; 
        ball.number = generateNumber(); 
        ball.spawnTime = Date.now(); // ‚è±Ô∏è Start timer for NEW ball
        trail = []; 
        ball.targetBasket = null;
    }

    function spawnPopup(text, x, y, color) { popups.push({ x: x, y: y, text: text, color: color, life: 40 }); }
    function shakeScreen() { canvas.style.transform = "translate(10px, 0)"; setTimeout(() => canvas.style.transform = "translate(-10px, 0)", 50); setTimeout(() => canvas.style.transform = "translate(10px, 0)", 100); setTimeout(() => canvas.style.transform = "translate(0, 0)", 150); }

    function endGame() {
        gameState = "GAMEOVER";
        sessionData.endTime = Date.now();
        sessionData.duration = (sessionData.endTime - sessionData.startTime) / 1000;
        
        console.log("=== FINAL BALL HISTORY ===");
        console.table(sessionData.ballHistory); // Prints nice table in browser console

        window.parent.postMessage({ type: 'GAME_OVER', data: sessionData }, '*');

        restartBtn.style.display = "block";
    }

    // ... Drawing functions same as before ...
    function drawRoundedRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); }
    function drawInstructions() { ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.textAlign = "center"; ctx.fillStyle = "#00f3ff"; ctx.font = "900 40px " + t.font; ctx.shadowBlur = 20; ctx.shadowColor = "#00f3ff"; ctx.fillText(t.title, canvas.width/2, 150); ctx.shadowBlur = 0; ctx.fillStyle = "white"; ctx.font = "20px " + t.font; ctx.fillText(t.howTo, canvas.width/2, 240); ctx.font = "16px " + t.font; ctx.fillStyle = "#aaa"; ctx.fillText(t.rule1, canvas.width/2, 280); ctx.fillText(t.rule2, canvas.width/2, 310); if (Math.floor(Date.now() / 500) % 2 === 0) { ctx.fillStyle = "#00ff00"; ctx.font = "bold 24px " + t.font; ctx.fillText(t.start, canvas.width/2, 450); } }
    function draw() { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = "rgba(0, 243, 255, 0.1)"; ctx.lineWidth = 1; for(let x=0; x<=canvas.width; x+=40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); } for(let y=0; y<=canvas.height; y+=40) { let drawY = y + gridOffset; if(drawY > canvas.height) drawY -= canvas.height; ctx.beginPath(); ctx.moveTo(0, drawY); ctx.lineTo(canvas.width, drawY); ctx.stroke(); } ctx.fillStyle = "white"; stars.forEach(p => { ctx.globalAlpha = p.alpha * 0.5; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0; if (gameState === "INSTRUCTIONS") { drawInstructions(); return; } baskets.forEach(basket => { ctx.fillStyle = basket.active ? "white" : "rgba(0,0,0,0.8)"; ctx.strokeStyle = basket.color; ctx.lineWidth = 3; ctx.shadowBlur = basket.active ? 40 : 15; ctx.shadowColor = basket.color; drawRoundedRect(ctx, basket.x, basket.y, basket.width, basket.height, btnRadius); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0; ctx.fillStyle = basket.active ? "black" : basket.color; ctx.font = "900 24px " + t.font; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(basket.label, basket.x + basket.width / 2, basket.y + basket.height / 2 + 2); }); if (ball.state === "FALLING" || ball.state === "SUCKED") { for(let i=0; i<trail.length; i++) { let t = trail[i]; let alpha = i / trail.length; ctx.fillStyle = `rgba(255, 87, 51, ${alpha * 0.5})`; ctx.beginPath(); ctx.arc(t.x, t.y, t.size * (i/trail.length), 0, Math.PI * 2); ctx.fill(); } let grad = ctx.createRadialGradient(ball.x - 5, ball.y - 5, 2, ball.x, ball.y, ball.radius); grad.addColorStop(0, "#ff9933"); grad.addColorStop(0.3, "#ff5e00"); grad.addColorStop(1, "#a80000"); ctx.fillStyle = grad; ctx.shadowBlur = 20; ctx.shadowColor = "#ff5e00"; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = "white"; ctx.font = "bold 22px 'Orbitron'"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(ball.number, ball.x, ball.y + 2); } explosions.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4); }); ctx.globalAlpha = 1.0; popups.forEach(p => { ctx.fillStyle = p.color; ctx.font = "bold 24px 'Orbitron'"; ctx.shadowBlur = 10; ctx.shadowColor = p.color; ctx.globalAlpha = p.life / 40; ctx.fillText(p.text, p.x, p.y); }); ctx.globalAlpha = 1.0; ctx.shadowBlur = 0; ctx.fillStyle = "white"; ctx.font = "20px " + t.font; ctx.textAlign = "left"; ctx.fillText(t.score + ": " + score, 20, 80); let hearts = "‚ù§Ô∏è".repeat(lives); ctx.textAlign = "right"; ctx.fillText(hearts, canvas.width - 20, 80); }

    function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
    gameLoop();
</script>
</body>
</html>