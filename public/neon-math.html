<!DOCTYPE html>
<html>
<head>
    <title>Neon Math Arcade</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;700&family=Noto+Sans+Oriya:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Orbitron', 'Noto Sans Devanagari', 'Noto Sans Oriya', sans-serif; 
            touch-action: none; 
        }
        canvas { 
            display: block; 
            margin: 0 auto; 
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
        }
        #restartBtn {
            display: none; 
            position: absolute; 
            top: 60%; left: 50%; 
            transform: translate(-50%, -50%); 
            padding: 15px 40px; 
            font-size: 24px; 
            font-family: 'Orbitron', sans-serif;
            background: rgba(0, 0, 0, 0.9); 
            border: 2px solid #00f3ff; 
            border-radius: 15px; 
            color: #00f3ff; 
            cursor: pointer; 
            text-transform: uppercase;
            box-shadow: 0 0 30px #00f3ff;
            z-index: 100;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<button id="restartBtn" onclick="location.reload()">System Failure<br><span style="font-size:16px">Tap to Reboot</span></button>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const restartBtn = document.getElementById("restartBtn");

    canvas.width = window.innerWidth > 500 ? 400 : window.innerWidth; 
    canvas.height = window.innerHeight;

    // --- üåê LOCALIZATION ---
    const dictionary = {
        en: { score: "SCORE", lives: "LIVES", even: "EVEN", odd: "ODD", title: "NEON MATH", howTo: "HOW TO PLAY:", rule1: "Tap EVEN for: 0, 2, 4...", rule2: "Tap ODD for: 1, 3, 5...", start: "TAP TO START", gameOver: "System Failure", reboot: "Tap to Reboot", font: "'Orbitron'" },
        hin: { score: "‡§∏‡•ç‡§ï‡•ã‡§∞", lives: "‡§ú‡•Ä‡§µ‡§®", even: "‡§∏‡§Æ", odd: "‡§µ‡§ø‡§∑‡§Æ", title: "‡§®‡§ø‡§Ø‡•ã‡§® ‡§ó‡§£‡§ø‡§§", howTo: "‡§ï‡•à‡§∏‡•á ‡§ñ‡•á‡§≤‡•á‡§Ç:", rule1: "‡§∏‡§Æ ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç: 0, 2, 4...", rule2: "‡§µ‡§ø‡§∑‡§Æ ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç: 1, 3, 5...", start: "‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ü‡•à‡§™ ‡§ï‡§∞‡•á‡§Ç", gameOver: "‡§ñ‡•á‡§≤ ‡§ñ‡§§‡•ç‡§Æ", reboot: "‡§™‡•Å‡§®‡§É ‡§Ü‡§∞‡§Ç‡§≠ ‡§ï‡§∞‡•á‡§Ç", font: "'Noto Sans Devanagari'" },
        odi: { score: "‡¨∏‡≠ç‡¨ï‡≠ã‡¨∞", lives: "‡¨ú‡≠Ä‡¨¨‡¨®", even: "‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ", odd: "‡¨Ö‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ", title: "‡¨®‡¨ø‡¨ì‡¨®‡≠ç ‡¨ó‡¨£‡¨ø‡¨§", howTo: "‡¨ï‡¨ø‡¨™‡¨∞‡¨ø ‡¨ñ‡≠á‡¨≥‡¨ø‡¨¨‡≠á:", rule1: "‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ ‡¨∏‡¨Ç‡¨ñ‡≠ç‡≠ü‡¨æ ‡¨¨‡¨æ‡¨õ‡¨®‡≠ç‡¨§‡≠Å: 0, 2, 4...", rule2: "‡¨Ö‡¨Ø‡≠Å‡¨ó‡≠ç‡¨Æ ‡¨∏‡¨Ç‡¨ñ‡≠ç‡≠ü‡¨æ ‡¨¨‡¨æ‡¨õ‡¨®‡≠ç‡¨§‡≠Å: 1, 3, 5...", start: "‡¨Ü‡¨∞‡¨Æ‡≠ç‡¨≠ ‡¨ï‡¨∞‡¨ø‡¨¨‡¨æ‡¨ï‡≠Å ‡¨ü‡≠ç‡≠ü‡¨æ‡¨™‡≠ç ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å", gameOver: "‡¨ñ‡≠á‡¨≥ ‡¨∂‡≠á‡¨∑", reboot: "‡¨™‡≠Å‡¨®‡¨É ‡¨Ü‡¨∞‡¨Æ‡≠ç‡¨≠ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å", font: "'Noto Sans Oriya'" }
    };

    const urlParams = new URLSearchParams(window.location.search);
    const langCode = urlParams.get('lang') || 'en';
    const t = dictionary[langCode] || dictionary['en'];

    restartBtn.innerHTML = `${t.gameOver}<br><span style="font-size:16px">${t.reboot}</span>`;
    restartBtn.style.fontFamily = t.font;

    // --- üìä ANALYTICS ---
    let sessionData = { startTime: null, endTime: null, duration: 0, totalCorrect: 0, totalWrong: 0, totalMissed: 0, ballHistory: [] };

    // --- GAME STATE ---
    let stars = [], explosions = [], popups = [], trail = [];         
    let gameState = "INSTRUCTIONS"; 
    let score = 0;
    let lives = 3; 
    let gameSpeed = 4;
    let gridOffset = 0;     

    // ü™® ASTEROID SETUP
    let ball = { 
        x: canvas.width / 2, 
        y: -100, 
        radius: 30, 
        number: generateNumber(), 
        state: "FALLING", 
        targetBasket: null,
        spawnTime: null,
        angle: 0,
        rotationSpeed: 0.02,
        vertices: [] 
    };

    const btnHeight = 60; 
    const btnY = canvas.height - btnHeight - 30; 

    let baskets = [
        { label: t.even, x: 20, y: btnY, width: (canvas.width/2)-25, height: btnHeight, color: "#00f3ff", active: false, type: "EVEN" },
        { label: t.odd, x: (canvas.width/2)+5, y: btnY, width: (canvas.width/2)-25, height: btnHeight, color: "#ff0099", active: false, type: "ODD" }
    ];

    for(let i=0; i<80; i++) {
        stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2, speed: Math.random() * 0.5 + 0.1, alpha: Math.random() });
    }

    // --- INPUT ---
    canvas.addEventListener('pointerdown', (e) => {
        if (gameState === "INSTRUCTIONS") {
            gameState = "PLAYING";
            sessionData.startTime = Date.now();
            generateAsteroidShape(); 
            ball.spawnTime = Date.now(); 
            return;
        }

        if (gameState === "GAMEOVER" || ball.state === "SUCKED") return;

        // üõë SUCTION DISABLE (If too close to shield)
        if (ball.y + ball.radius > btnY - 20) {
            return; 
        }

        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        baskets.forEach(basket => {
            if (clickX > basket.x && clickX < basket.x + basket.width &&
                clickY > basket.y && clickY < basket.y + basket.height) {
                
                basket.active = true;
                setTimeout(() => basket.active = false, 150);
                startSuck(basket);
            }
        });
    });

    // --- LOGIC ---
    function generateNumber() { return Math.floor(Math.random() * 100); }
    
    function generateAsteroidShape() {
        ball.vertices = [];
        const segments = 12;
        for (let i = 0; i < segments; i++) {
            const angle = (Math.PI * 2 * i) / segments;
            const r = ball.radius * (0.7 + Math.random() * 0.6); 
            ball.vertices.push({
                x: Math.cos(angle) * r,
                y: Math.sin(angle) * r
            });
        }
    }

    function startSuck(basket) { ball.state = "SUCKED"; ball.targetBasket = basket; }

    function createExplosion(x, y, color) {
        for(let i=0; i<25; i++) {
            explosions.push({ 
                x: x, y: y, 
                vx: (Math.random() - 0.5) * 15, 
                vy: (Math.random() - 0.5) * 15, 
                life: 1.0, 
                color: color,
                size: Math.random() * 5 
            });
        }
    }

    function update() {
        stars.forEach(p => { p.y += p.speed; if (p.y > canvas.height) p.y = 0; });
        gridOffset = (gridOffset + 1) % 40;

        if (gameState !== "PLAYING") return;

        if (ball.state === "FALLING") {
            ball.y += gameSpeed;
            ball.angle += ball.rotationSpeed; 

            // üí® NEW SPACE DUST TRAIL LOGIC (Replaces Droplet)
            if (Math.random() > 0.4) { // Chance to spawn dust
                trail.push({
                    x: ball.x + (Math.random() - 0.5) * ball.radius, 
                    y: ball.y - ball.radius * 0.5, 
                    size: Math.random() * 3 + 1,
                    alpha: 0.8,
                    speedX: (Math.random() - 0.5),
                    speedY: Math.random() * 2 // Dust drifts up/back
                });
            }
            
            if (ball.y > canvas.height + 50) {
                recordBallEvent("MISSED", null);
                sessionData.totalMissed++;
                loseLife();
                resetBall();
            }

        } else if (ball.state === "SUCKED") {
            let targetX = ball.targetBasket.x + ball.targetBasket.width / 2;
            let targetY = ball.targetBasket.y + ball.targetBasket.height / 2;
            ball.x += (targetX - ball.x) * 0.25; ball.y += (targetY - ball.y) * 0.25; ball.radius *= 0.85;
            ball.angle += 0.2; 

            if (ball.radius < 2) {
                validateCatch(ball.targetBasket);
                resetBall();
            }
        }

        // Update Dust Particles
        for (let i = trail.length - 1; i >= 0; i--) {
            trail[i].y -= trail[i].speedY; // Drift back
            trail[i].x += trail[i].speedX; // Spread
            trail[i].alpha -= 0.04; // Fade out
            if (trail[i].alpha <= 0) trail.splice(i, 1);
        }

        for (let i = explosions.length - 1; i >= 0; i--) { explosions[i].x += explosions[i].vx; explosions[i].y += explosions[i].vy; explosions[i].life -= 0.05; if (explosions[i].life <= 0) explosions.splice(i, 1); }
        for (let i = popups.length - 1; i >= 0; i--) { popups[i].y -= 2; popups[i].life -= 1; if (popups[i].life <= 0) popups.splice(i, 1); }
    }

    function recordBallEvent(result, basketChosen) {
        const endTime = Date.now();
        const startTime = ball.spawnTime || endTime; 
        sessionData.ballHistory.push({
            number: ball.number,
            spawnTime: new Date(startTime).toISOString(),
            endTime: new Date(endTime).toISOString(),
            reactionTimeMs: endTime - startTime,
            result: result,
            basketChosen: basketChosen
        });
    }

    function validateCatch(basket) {
        let isNumberEven = ball.number % 2 === 0;
        let isBasketEven = basket.type === "EVEN"; 

        if ((isBasketEven && isNumberEven) || (!isBasketEven && !isNumberEven)) {
            recordBallEvent("CORRECT", basket.type);
            sessionData.totalCorrect++;
            score += 10;
            gameSpeed += 0.2;
            createExplosion(basket.x + basket.width/2, basket.y, "#00ff00");
            spawnPopup("+10", basket.x + basket.width/2, basket.y - 50, "#00ff00");
        } else {
            recordBallEvent("WRONG", basket.type);
            sessionData.totalWrong++;
            createExplosion(basket.x + basket.width/2, basket.y, "red");
            spawnPopup("ERROR", basket.x + basket.width/2, basket.y - 50, "red");
            loseLife();
            shakeScreen();
        }
    }

    function loseLife() {
        lives--;
        if (lives <= 0) endGame();
        if (navigator.vibrate) navigator.vibrate(300);
    }

    function resetBall() {
        ball.state = "FALLING"; 
        ball.y = -60; 
        ball.x = Math.random() * (canvas.width - 60) + 30; 
        ball.radius = 30; 
        ball.number = generateNumber(); 
        ball.spawnTime = Date.now();
        ball.angle = 0;
        ball.rotationSpeed = (Math.random() - 0.5) * 0.1; 
        generateAsteroidShape(); 
        trail = []; // Clear dust
        ball.targetBasket = null;
    }

    function spawnPopup(text, x, y, color) { popups.push({ x: x, y: y, text: text, color: color, life: 40 }); }
    function shakeScreen() { canvas.style.transform = "translate(10px, 0)"; setTimeout(() => canvas.style.transform = "translate(-10px, 0)", 50); setTimeout(() => canvas.style.transform = "translate(10px, 0)", 100); setTimeout(() => canvas.style.transform = "translate(0, 0)", 150); }

    function endGame() {
        gameState = "GAMEOVER";
        sessionData.endTime = Date.now();
        sessionData.duration = (sessionData.endTime - sessionData.startTime) / 1000;
        console.log("=== FINAL BALL HISTORY ===", sessionData.ballHistory); 
        window.parent.postMessage({ type: 'GAME_OVER', data: sessionData }, '*');
        restartBtn.style.display = "block";
    }

    // üõ°Ô∏è DRAW SHIELD
    function drawShield(ctx, x, y, width, height, color, isActive) {
        ctx.shadowBlur = isActive ? 50 : 20;
        ctx.shadowColor = color;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + width, y); ctx.stroke();

        let grad = ctx.createLinearGradient(x, y, x, y + height);
        grad.addColorStop(0, color); 
        grad.addColorStop(1, "rgba(0,0,0,0)"); 

        ctx.fillStyle = isActive ? "white" : grad;
        ctx.globalAlpha = isActive ? 0.8 : 0.3; 
        ctx.fillRect(x, y, width, height);
        
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y); ctx.lineTo(x, y + height);
        ctx.moveTo(x + width, y); ctx.lineTo(x + width, y + height);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
    }

    // ü™® DRAW ASTEROID
    function drawAsteroid(ctx, ball) {
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.angle);

        let grad = ctx.createRadialGradient(-10, -10, 5, 0, 0, ball.radius);
        grad.addColorStop(0, "#887766"); 
        grad.addColorStop(1, "#332211"); 

        ctx.fillStyle = grad;
        ctx.strokeStyle = "#554433";
        ctx.lineWidth = 2;

        ctx.beginPath();
        if (ball.vertices.length > 0) {
            ball.vertices.forEach((v, i) => {
                if (i === 0) ctx.moveTo(v.x, v.y);
                else ctx.lineTo(v.x, v.y);
            });
            ctx.closePath();
        }
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = "white";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 5;
        ctx.font = "bold 24px 'Orbitron'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(ball.number, ball.x, ball.y + 2);
        ctx.shadowBlur = 0;
    }

    function drawInstructions() {
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.textAlign = "center";
        ctx.fillStyle = "#00f3ff"; ctx.font = "900 40px " + t.font; ctx.shadowBlur = 20; ctx.shadowColor = "#00f3ff"; ctx.fillText(t.title, canvas.width/2, 150); ctx.shadowBlur = 0;
        ctx.fillStyle = "white"; ctx.font = "20px " + t.font; ctx.fillText(t.howTo, canvas.width/2, 240);
        ctx.font = "16px " + t.font; ctx.fillStyle = "#aaa"; ctx.fillText(t.rule1, canvas.width/2, 280); ctx.fillText(t.rule2, canvas.width/2, 310);
        if (Math.floor(Date.now() / 500) % 2 === 0) { ctx.fillStyle = "#00ff00"; ctx.font = "bold 24px " + t.font; ctx.fillText(t.start, canvas.width/2, 450); }
    }

    function draw() {
        ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = "rgba(0, 243, 255, 0.1)"; ctx.lineWidth = 1;
        for(let x=0; x<=canvas.width; x+=40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
        for(let y=0; y<=canvas.height; y+=40) { let drawY = y + gridOffset; if(drawY > canvas.height) drawY -= canvas.height; ctx.beginPath(); ctx.moveTo(0, drawY); ctx.lineTo(canvas.width, drawY); ctx.stroke(); }

        ctx.fillStyle = "white"; stars.forEach(p => { ctx.globalAlpha = p.alpha * 0.5; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0;

        if (gameState === "INSTRUCTIONS") { drawInstructions(); return; }

        baskets.forEach(basket => {
            drawShield(ctx, basket.x, basket.y, basket.width, basket.height, basket.color, basket.active);
            ctx.fillStyle = basket.active ? "black" : basket.color;
            ctx.font = "900 24px " + t.font; ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
            ctx.fillText(basket.label, basket.x + basket.width / 2, basket.y + basket.height / 2 + 2);
        });

        if (ball.state === "FALLING" || ball.state === "SUCKED") {
            // üí® DRAW SPACE DUST TRAIL
            trail.forEach(t => {
                ctx.fillStyle = `rgba(139, 130, 120, ${t.alpha})`; // Greyish/Brown dust
                ctx.beginPath(); 
                ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2); 
                ctx.fill(); 
            });
            drawAsteroid(ctx, ball);
        }

        explosions.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, p.size, p.size); }); ctx.globalAlpha = 1.0;
        popups.forEach(p => { ctx.fillStyle = p.color; ctx.font = "bold 24px 'Orbitron'"; ctx.shadowBlur = 10; ctx.shadowColor = p.color; ctx.globalAlpha = p.life / 40; ctx.fillText(p.text, p.x, p.y); }); ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;

        ctx.fillStyle = "white"; ctx.font = "20px " + t.font; ctx.textAlign = "left"; ctx.fillText(t.score + ": " + score, 20, 80);
        let hearts = "‚ù§Ô∏è".repeat(lives); ctx.textAlign = "right"; ctx.fillText(hearts, canvas.width - 20, 80);
    }

    function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
    gameLoop();
</script>
</body>
</html>